# 项目系统性重构方案

## 目录

1. [引言](#1-引言)
2. [重构战略目标与关键指标](#2-重构战略目标与关键指标)
3. [实施范围与边界](#3-实施范围与边界)
4. [核心重构策略与方法论](#4-核心重构策略与方法论)
5. [分阶段实施步骤](#5-分阶段实施步骤)
6. [风险评估矩阵及应对措施](#6-风险评估矩阵及应对措施)
7. [模块拆分计划与依赖关系](#7-模块拆分计划与依赖关系)
8. [统一接口设计规范与项目结构](#8-统一接口设计规范与项目结构)
9. [业务域重构方案详细设计](#9-业务域重构方案详细设计)
10. [质量保障措施与验收标准](#10-质量保障措施与验收标准)
11. [结论](#11-结论)

## 1. 引言

本方案基于领域驱动设计(DDD)理论框架，对当前项目的设计架构与代码实现进行系统性审查，识别存在的问题并提出重构方案。目标是使项目严格遵循高内聚低耦合原则，提升代码的可维护性、可扩展性与可测试性，准确反映业务领域知识并支持业务规则的灵活变化。

## 2. 重构战略目标与关键指标

### 2.1 战略目标

| 目标维度 | 具体目标 | 核心价值 |
|---------|---------|---------|
| **架构边界** | 建立清晰的领域边界，确保依赖方向正确 | 降低耦合度，提高系统可维护性 |
| **域模型质量** | 实现充血模型，将业务规则封装到领域对象中 | 提高业务规则的复用性和一致性 |
| **异常处理** | 分离领域异常与HTTP异常，实现领域模型的纯业务语义 | 提高领域模型的可复用性 |
| **事务管理** | 统一事务管理，明确事务边界 | 提高数据一致性，降低并发冲突 |
| **数据访问** | 抽象仓储接口，解耦数据访问与业务逻辑 | 提高系统的可测试性和可迁移性 |
| **CQRS实现** | 明确实现CQRS模式，分离Commands与Queries | 优化查询性能，支持独立扩展 |
| **事件驱动** | 实现完整的事件驱动架构，定义专门的Event Handler | 提高系统间的松耦合度，支持异步处理 |
| **Shared Kernel** | 拆分膨胀的Shared Kernel，分离领域契约与技术横切 | 提高共享代码的可维护性和可治理性 |

### 2.2 关键指标

| 指标类型 | 指标名称 | 当前值 | 预期值 | 评估方法 |
|---------|---------|--------|--------|----------|
| **性能指标** | 平均查询响应时间 | 800ms | 200ms | 使用JMeter进行压力测试 |
| | 系统吞吐量 | 500 QPS | 1000 QPS | 使用JMeter进行负载测试 |
| | 产品发布失败率 | 15% | 5% | 统计生产环境数据 |
| **可维护性指标** | 代码覆盖率 | 60% | 80% | 使用SonarQube进行代码分析 |
| | 新功能开发周期 | 3周 | 1.5周 | 统计开发时间 |
| | 代码复杂度 | 平均圈复杂度15 | 平均圈复杂度10 | 使用SonarQube进行代码分析 |
| **业务指标** | 产品列表页跳出率 | 40% | 25% | 统计用户行为数据 |
| | 产品发布成功率 | 85% | 95% | 统计业务数据 |
| | 新功能上线频率 | 每3周1次 | 每2周1次 | 统计上线次数 |
| **架构质量指标** | 依赖反转率 | >50% | <5% | 静态代码分析工具 |
| | 领域模型贫血率 | >80% | <20% | 代码审查 |
| | 事务管理统一率 | <30% | >90% | 静态代码分析工具 |

## 3. 实施范围与边界

### 3.1 实施范围

| 业务域 | 核心功能 | 重构重点 |
|---------|---------|---------|
| **Catalog** | 产品/服务类型管理 | CQRS实现、事件驱动架构、依赖倒置修复 |
| **Contract** | 合同/权益/台账/预占 | 事务管理、领域模型重构、事件驱动 |
| **Financial** | 导师结算/申诉/支付参数 | 领域规则封装、事务管理、事件驱动 |
| **Services** | 各种session/service registry | 异步处理、Outbox模式、事件驱动 |
| **Identity** | 用户/角色/档案 | 领域模型重构、依赖倒置修复 |
| **Placement** | 职位申请/推荐 | 事件驱动架构、领域模型重构 |
| **Query** | 读模型/报表 | CQRS实现、Read Model优化 |

### 3.2 实施边界

1. **不修改现有API接口**：保持外部接口不变，仅修改内部实现
2. **兼容现有数据结构**：确保重构后能正确读取现有数据
3. **渐进式重构**：从核心业务域开始，逐步推广到其他域
4. **优先解决高风险问题**：先修复事务与副作用处理的高风险路径
5. **保持系统可用性**：重构过程中确保系统正常运行
6. **支持独立重构**：各业务域可独立进行重构，不影响其他域
7. **不改变业务逻辑**：严格保持原有业务逻辑和功能表现
8. **模块化设计**：确保各业务域边界清晰，依赖关系正确

## 4. 核心重构策略与方法论

### 4.1 核心重构策略

1. **依赖方向修正**：
   - Domain层不依赖Infrastructure层和框架
   - Application层不依赖API DTO和DB Schema
   - Shared Kernel只放领域契约，不放技术细节

2. **分层架构实现**：
   - Domain层：纯业务逻辑，包含实体、值对象、聚合、仓储接口
   - Application层：用例编排，包含命令/查询、事务管理、事件发布
   - Infrastructure层：技术实现，包含仓储实现、事件总线、外部客户端
   - Interface层：API接口，包含控制器、请求DTO、错误映射

3. **CQRS实现**：
   - 命令和查询分离
   - 命令负责修改数据，查询负责读取数据
   - 命令使用领域模型，查询使用Read Model

4. **事件驱动架构**：
   - 领域事件：领域中发生的重要业务事件
   - 事件总线：负责事件传输
   - 事件处理器：处理领域事件
   - Outbox模式：确保事件可靠投递

5. **统一事务管理**：
   - Application层管理事务边界
   - 使用UnitOfWork模式
   - 事务内只做数据库操作，事务后发布事件

### 4.2 方法论

1. **领域驱动设计(DDD)**：
   - 建立统一语言
   - 划分边界上下文
   - 设计聚合和值对象
   - 实现领域服务

2. **整洁架构**：
   - 依赖规则：外层依赖内层，内层不依赖外层
   - 可测试性：易于单元测试
   - 可扩展性：支持多种实现

3. **增量重构**：
   - 先修复核心问题
   - 逐步推广到其他模块
   - 每次重构后进行测试

4. **测试驱动开发(TDD)**：
   - 编写测试用例
   - 实现功能
   - 运行测试
   - 重构代码

5. **持续集成/持续部署(CI/CD)**：
   - 自动化构建
   - 自动化测试
   - 自动化部署

## 5. 分阶段实施步骤

### 5.1 第一阶段：基础准备（1-2周）

#### 5.1.1 任务清单
1. 建立重构团队和沟通机制
2. 制定详细的重构计划和时间表
3. 开展DDD、CQRS、事件驱动架构培训
4. 建立依赖红线，防止新代码继续加深耦合
5. 拆分`src/shared/`为`shared-kernel`和`platform`
6. 实现领域异常基类，移除HTTP依赖
7. 定义核心值对象和聚合根接口
8. 抽象CQRS仓储接口，分离读写逻辑
9. 建立UnitOfWork接口，统一事务管理
10. 实现内存型Event Bus

#### 5.1.2 里程碑
- 完成基础架构搭建
- 核心接口定义完成
- 事件总线实现完成

### 5.2 第二阶段：核心业务域重构（3-4周）

#### 5.2.1 任务清单
1. 选择一个核心业务域（如Catalog或Contract）进行重构
2. 实现领域模型（实体、值对象、聚合）
3. 实现命令和查询处理器
4. 实现事件驱动架构
5. 实现Outbox模式，确保事件可靠投递
6. 实现事务管理，绑定到Command执行
7. 编写单元测试和集成测试
8. 验证重构后的功能和性能

#### 5.2.2 里程碑
- 核心业务域重构完成
- CQRS模式实现完成
- 事件驱动架构实现完成
- 测试覆盖率达到80%以上

### 5.3 第三阶段：其他业务域重构（4-6周）

#### 5.3.1 任务清单
1. 按照核心业务域的模板，重构其他业务域
2. 实现跨域事件处理
3. 优化Read Model，提高查询性能
4. 实现事件监控和统计功能
5. 编写全面的测试用例

#### 5.3.2 里程碑
- 所有业务域重构完成
- 跨域事件处理实现完成
- Read Model优化完成
- 测试覆盖率达到85%以上

### 5.4 第四阶段：优化与验证（2-3周）

#### 5.4.1 任务清单
1. 性能优化，包括查询优化、缓存策略等
2. 安全审计，确保系统安全
3. 进行全面的回归测试
4. 执行性能测试，比较重构前后的性能差异
5. 编写重构总结报告
6. 制定后续维护和演进计划

#### 5.4.2 里程碑
- 性能测试通过
- 回归测试通过
- 重构总结报告完成

## 6. 风险评估矩阵及应对措施

| 风险类型 | 风险描述 | 影响程度 | 可能性 | 应对措施 |
|---------|---------|---------|-------|---------|
| **技术风险** | 重构过程中引入新bug | 高 | 中 | 1. 编写全面的测试用例<br>2. 采用增量重构方式<br>3. 定期代码审查<br>4. 实现持续集成和自动化测试 |
| **技术风险** | CQRS实现增加系统复杂度 | 中 | 中 | 1. 提供详细的文档和培训<br>2. 建立清晰的代码规范<br>3. 先在核心模块实现，再推广到其他模块 |
| **技术风险** | 内存型Event Bus可能导致事件丢失 | 高 | 中 | 1. 实现Outbox模式<br>2. 支持事件重试和幂等处理<br>3. 建立事件监控机制 |
| **技术风险** | Query模型与Command模型数据不一致 | 中 | 中 | 1. 实现事件驱动的Read Model更新<br>2. 建立数据一致性检查机制<br>3. 提供数据同步工具 |
| **进度风险** | 重构周期超出预期 | 中 | 中 | 1. 明确各阶段交付物<br>2. 建立每日站会跟踪进度<br>3. 预留缓冲时间<br>4. 优先实现核心功能 |
| **团队风险** | 团队对DDD理解不一致 | 中 | 高 | 1. 开展统一的DDD培训<br>2. 建立DDD实践指南<br>3. 成立重构小组，配备DDD专家 |
| **团队风险** | 团队对CQRS和事件驱动模式不熟悉 | 中 | 高 | 1. 提供详细的培训和示例<br>2. 建立内部技术分享机制<br>3. 引入外部专家指导 |
| **兼容性风险** | 重构后与其他模块不兼容 | 高 | 低 | 1. 保持API接口不变<br>2. 实现适配层<br>3. 进行充分的集成测试<br>4. 建立灰度发布机制 |

## 7. 模块拆分计划与依赖关系图

### 7.1 模块拆分计划

| 模块名称 | 职责 | 依赖关系 |
|---------|------|---------|
| **shared-kernel** | 跨域共享的领域概念 | 无依赖 |
| **platform** | 技术横切关注点 | 无依赖 |
| **domain-catalog** | Catalog域的领域模型 | 依赖shared-kernel |
| **domain-contract** | Contract域的领域模型 | 依赖shared-kernel |
| **domain-financial** | Financial域的领域模型 | 依赖shared-kernel |
| **domain-services** | Services域的领域模型 | 依赖shared-kernel |
| **domain-identity** | Identity域的领域模型 | 依赖shared-kernel |
| **domain-calendar** | Calendar域的领域模型 | 依赖shared-kernel |
| **application** | 用例编排 | 依赖所有domain模块 |
| **infrastructure** | 技术实现 | 依赖application和所有domain模块 |
| **api** | API接口 | 依赖application |
| **query** | 读模型/报表 | 依赖infrastructure |

### 7.2 依赖关系图

```
┌─────────────────────────────────────────────────────────────────┐
│                       Interface Layer (API)                     │
└───────────────────────────────────┬─────────────────────────────┘
                                     │
┌───────────────────────────────────▼─────────────────────────────┐
│                      Application Layer                          │
└───────────────────────────────────┬─────────────────────────────┘
                                     │
┌───────────────────────────────────▼─────────────────────────────┐
│                         Domain Layer                            │
│  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐ ┌───────────┐│
│  │Catalog Domain│ │Contract Domain│ │Financial Domain│ │...其他域││
│  └──────────────┘ └──────────────┘ └──────────────┘ └───────────┘│
└───────────────────────────────────┬─────────────────────────────┘
                                     │
┌───────────────────────────────────▼─────────────────────────────┐
│                      Infrastructure Layer                      │
└───────────────────────────────────┬─────────────────────────────┘
                                     │
┌───────────────────────────────────▼─────────────────────────────┐
│                         Query Layer                            │
└─────────────────────────────────────────────────────────────────┘
```

## 8. 统一接口设计规范与项目结构

### 8.1 项目结构

```
src/
├── api/                                 # API层
│   └── controllers/                     # 控制器
│       └── catalog/                     # Catalog域控制器
│           ├── products.controller.ts    # 产品API控制器
│           └── service-types.controller.ts # 服务类型API控制器
│   └── dto/                              # 请求/响应DTO
│       └── catalog/                      # Catalog域DTO
│           ├── product/                  # 产品相关DTO
│           └── service-type/             # 服务类型相关DTO
│   └── errors/                           # API错误映射
│       └── catalog/                      # Catalog域错误映射
├── application/                         # 应用层
│   ├── commands/                         # 命令定义
│   │   └── catalog/                      # Catalog域命令
│   │       ├── product/                  # 产品相关命令
│   │       │   ├── create-product.command.ts     # 创建产品命令
│   │       │   ├── update-product.command.ts     # 更新产品命令
│   │       │   ├── update-product-status.command.ts # 更新产品状态命令
│   │       │   ├── add-product-item.command.ts   # 添加产品项命令
│   │       │   ├── remove-product-item.command.ts # 移除产品项命令
│   │       │   └── product.command.handler.ts    # 产品命令处理器
│   │       └── service-type/             # 服务类型相关命令
│   │           ├── create-service-type.command.ts # 创建服务类型命令
│   │           └── service-type.command.handler.ts # 服务类型命令处理器
│   │
│   └── queries/                          # 查询定义
│       └── catalog/                      # Catalog域查询
│           ├── product/                  # 产品相关查询
│           │   ├── get-product.query.ts           # 获取产品查询
│           │   ├── search-products.query.ts       # 搜索产品查询
│           │   └── product.query.handler.ts       # 产品查询处理器
│           └── service-type/             # 服务类型相关查询
│               ├── get-service-type.query.ts      # 获取服务类型查询
│               └── service-type.query.handler.ts  # 服务类型查询处理器
│   └── event-handlers/                   # 事件处理器
│   │   └── catalog/                      # Catalog域事件处理器
│   │       ├── product-published.handler.ts  # 产品发布事件处理器
│   │       ├── product-updated.handler.ts    # 产品更新事件处理器
│   │       └── product-status-changed.handler.ts # 产品状态变更事件处理器
│   └── transaction/                      # 事务管理
│       ├── unit-of-work.interface.ts     # 工作单元接口
│       └── unit-of-work.impl.ts          # 工作单元实现
├── domains/                             # 领域层
│   ├── catalog/                          # Catalog域
│   │   ├── aggregates/                   # 聚合根
│   │   │   └── product.aggregate.ts       # Product聚合根实现
│   │   ├── entities/                     # 实体
│   │   │   └── product-item.entity.ts     # ProductItem实体
│   │   ├── value-objects/                # 值对象
│   │   │   ├── price.vo.ts                # Price值对象
│   │   │   ├── product-status.vo.ts       # ProductStatus值对象
│   │   │   └── ...
│   │   ├── domain-events/                # 领域事件
│   │   │   ├── product-published.event.ts # 产品发布事件
│   │   │   ├── product-updated.event.ts   # 产品更新事件
│   │   │   └── product-status-changed.event.ts # 产品状态变更事件
│   │   ├── repository/                   # 仓储接口
│   │   │   ├── product.repository.interface.ts # 产品命令仓储接口
│   │   │   └── product.query-repository.interface.ts # 产品查询仓储接口
│   │   ├── services/                     # 领域服务
│   │   │   ├── product-validation.service.ts   # 产品验证服务
│   │   │   └── product-snapshot.service.ts     # 产品快照服务
│   │   ├── rules/                        # 领域规则
│   │   │   ├── product-lifecycle.rules.ts      # 产品生命周期规则
│   │   │   └── product-pricing.rules.ts        # 产品定价规则
│   │   └── exceptions/                   # 领域异常
│   │       └── product.exception.ts       # 产品领域异常
│   ├── contract/                         # Contract域
│   ├── financial/                        # Financial域
│   ├── services/                         # Services域
│   ├── identity/                         # Identity域
│   ├── placement/                        # Placement域
│   └── calendar/                         # Calendar域
├── infrastructure/                      # 基础设施层
│   ├── database/                         # 数据库实现
│   │   ├── schema/                       # Drizzle schema
│   │   │   ├── products.schema.ts          # 产品数据库模式
│   │   │   ├── product-items.schema.ts     # 产品项数据库模式
│   │   │   └── service-types.schema.ts     # 服务类型数据库模式
│   │   └── repositories/                  # 仓储实现
│   │       └── catalog/                    # Catalog域仓储实现
│   │           ├── product.repository.impl.ts # 产品命令仓储实现
│   │           └── product.query-repository.impl.ts # 产品查询仓储实现
│   ├── event-bus/                        # 事件总线
│   │   ├── core/                         # 事件总线核心
│   │   │   ├── event-bus.interface.ts      # 事件总线核心接口
│   │   │   ├── event-bus.impl.ts           # 内存型事件总线实现
│   │   │   ├── event.types.ts              # 事件类型定义
│   │   │   └── subscription.types.ts       # 订阅相关类型定义
│   │   ├── handlers/                      # 事件处理器接口
│   │   │   ├── event-handler.interface.ts  # 事件处理器接口
│   │   │   └── base-event.handler.ts       # 基础事件处理器实现
│   │   └── persistence/                   # 事件持久化
│   │       └── event-persistence.interface.ts # 预留的事件持久化接口
│   └── external/                         # 外部客户端
├── platform/                             # 技术横切
│   ├── decorators/                       # 装饰器
│   ├── guards/                           # 守卫
│   ├── interceptors/                     # 拦截器
│   ├── logging/                          # 日志
│   └── utils/                            # 工具函数
└── shared-kernel/                        # 共享内核
    ├── events/                           # 共享事件
    ├── types/                            # 共享类型
    └── value-objects/                    # 共享值对象
```

### 8.2 分层架构实现

#### 8.2.1 API层

API层是系统的外部入口，负责处理HTTP请求和响应。它的主要职责包括：

1. **请求处理**：接收和验证HTTP请求
2. **DTO转换**：将请求DTO转换为应用层命令/查询，将应用层结果转换为响应DTO
3. **错误处理**：将领域异常和应用异常转换为HTTP响应
4. **路由管理**：定义API路由和端点

API层的设计遵循以下原则：

- 不包含业务逻辑，仅负责请求/响应处理
- 控制器按业务域组织，如`catalog/products.controller.ts`
- DTO按业务域和功能组织，如`catalog/product/create-product.request.dto.ts`
- 错误映射按业务域组织，实现领域异常到HTTP响应的转换

#### 8.2.2 应用层

应用层是系统的用例编排层，负责协调领域对象、服务和基础设施来完成业务用例。它的主要职责包括：

1. **命令处理**：处理业务命令，协调领域对象完成状态变更
2. **查询处理**：处理业务查询，返回所需数据
3. **事务管理**：管理业务事务，确保数据一致性
4. **事件发布**：发布领域事件，实现系统间的松耦合

应用层的设计遵循以下原则：

- 按CQRS模式组织，分离命令和查询
- 命令和查询按业务域组织，如`commands/catalog/product/`
- 命令处理器负责执行命令，更新领域模型
- 查询处理器负责执行查询，返回Read Model
- 事件处理器负责处理领域事件，实现跨域协作

#### 8.2.3 领域层

领域层是系统的核心，包含业务规则和领域知识。它的主要职责包括：

1. **领域模型**：定义实体、值对象和聚合
2. **业务规则**：封装业务逻辑和不变量
3. **领域服务**：处理复杂业务逻辑
4. **领域事件**：表示领域中发生的重要业务事件

领域层的设计遵循以下原则：

- 不依赖基础设施层和框架
- 实现充血模型，将业务规则封装到领域对象中
- 按DDD战术模式组织，如实体、值对象、聚合、仓储接口等
- 领域事件表示领域中发生的重要业务变化

#### 8.2.4 基础设施层

基础设施层负责为上层提供技术支持，实现与外部系统的交互。它的主要职责包括：

1. **数据访问**：实现仓储接口，与数据库交互
2. **事件总线**：实现事件发布和订阅机制
3. **外部集成**：与外部系统和服务交互
4. **技术支持**：提供日志、监控、配置等技术支持

基础设施层的设计遵循以下原则：

- 依赖领域层和应用层的接口
- 实现接口驱动的设计，便于替换和测试
- 按功能模块组织，如数据库、事件总线、外部客户端等
- 提供可扩展的设计，支持多种实现

### 8.3 CQRS模式实现

CQRS（Command Query Responsibility Segregation）模式将系统的读写操作分离，分别优化。在本架构中，CQRS模式的具体实现如下：

#### 8.3.1 命令处理流程

1. API控制器接收HTTP请求
2. 转换为应用层命令
3. 命令处理器执行命令：
   - 加载领域模型
   - 执行业务逻辑
   - 更新领域模型
   - 发布领域事件
4. 返回执行结果

#### 8.3.2 查询处理流程

1. API控制器接收HTTP请求
2. 转换为应用层查询
3. 查询处理器执行查询：
   - 直接访问数据库或缓存
   - 返回Read Model
4. 返回查询结果

#### 8.3.3 CQRS实现要点

- 命令和查询使用不同的模型
- 命令修改状态，查询返回数据
- 命令和查询可以独立扩展
- 命令处理支持事务，查询处理不支持事务
- 命令发布领域事件，用于更新Read Model

### 8.4 事件驱动架构设计

事件驱动架构是本系统的核心设计原则之一，用于实现系统间的松耦合和异步协作。在本架构中，事件驱动架构的具体实现如下：

#### 8.4.1 事件类型

1. **领域事件**：表示领域中发生的重要业务事件，如`ProductPublishedEvent`
2. **集成事件**：表示跨域的业务事件，用于系统间协作
3. **技术事件**：表示系统级别的事件，如日志事件、监控事件等

#### 8.4.2 事件总线设计

事件总线是事件驱动架构的核心组件，负责事件的发布、订阅和分发。本架构采用内存型事件总线，具有以下特点：

1. **高性能**：事件处理延迟低，适合实时性要求高的场景
2. **简单易用**：实现简单，不需要额外的基础设施
3. **可扩展**：预留事件持久化和消息队列集成接口
4. **支持异步**：默认异步处理事件，避免阻塞主线程
5. **支持批量处理**：支持批量发布和订阅事件

#### 8.4.3 事件处理流程

1. 命令处理器执行命令，更新领域模型
2. 发布领域事件到事件总线
3. 事件总线将事件分发给所有订阅者
4. 事件处理器处理事件：
   - 更新Read Model
   - 执行跨域协作
   - 发送通知
   - 记录审计日志
5. 事件处理完成

### 8.5 接口设计规范

#### 8.5.1 领域接口规范

1. **仓储接口**：
   - 定义在domain层，实现在infrastructure层
   - 分离命令仓储和查询仓储
   - 使用泛型设计，支持多种实体类型

2. **领域服务接口**：
   - 纯业务逻辑，不依赖技术细节
   - 定义清晰的输入输出参数
   - 封装复杂的业务规则

3. **实体/值对象接口**：
   - 封装业务规则和不变量
   - 提供清晰的行为方法
   - 实现值相等性

#### 8.5.2 应用接口规范

1. **命令接口**：
   - 输入DTO，返回操作结果
   - 命名规范：`CreateProductCommand`
   - 包含命令元数据，如请求ID、用户ID等

2. **查询接口**：
   - 输入查询条件，返回Read Model
   - 命名规范：`GetProductQuery`
   - 支持分页、排序和过滤

3. **事件接口**：
   - 定义事件结构和处理器接口
   - 事件命名规范：`ProductPublishedEvent`
   - 事件结构包含id、type、payload、timestamp、metadata

#### 8.5.3 API接口规范

1. **RESTful API设计**：
   - 使用HTTP动词表示操作：GET、POST、PUT、DELETE
   - 使用资源路径表示资源：`/api/catalog/products`
   - 使用状态码表示操作结果

2. **统一的错误响应格式**：
   - 包含错误码、错误消息、错误详情
   - 使用标准HTTP状态码

3. **版本控制**：
   - 在URL中包含版本号：`/api/v1/catalog/products`
   - 支持多个版本并存

4. **输入验证**：
   - 使用DTO进行输入验证
   - 提供清晰的验证错误信息
   - 使用装饰器或验证库实现验证

#### 8.5.4 事件接口规范

1. **事件命名**：
   - 格式：`领域名.事件名.版本号`
   - 示例：`product.published.v1`

2. **事件结构**：
   - id：事件唯一标识符
   - type：事件类型
   - payload：事件数据
   - timestamp：事件发生时间
   - metadata：事件元数据，如trace ID、user ID等

3. **事件版本管理**：
   - 使用语义化版本号
   - 新增字段：向后兼容，旧订阅者可忽略
   - 修改字段：创建新版本事件
   - 删除字段：创建新版本事件

#### 8.5.5 API DTO设计规范

API DTO（Data Transfer Object）是API层与客户端之间的数据传输载体，用于定义API请求和响应的数据结构。DTO设计应遵循以下规范：

##### 8.5.5.1 命名规范

1. **文件命名**：
   - 请求DTO：`{resource}-{action}.request.dto.ts`，如`product-create.request.dto.ts`
   - 响应DTO：`{resource}-{action}.response.dto.ts`，如`product-detail.response.dto.ts`
   - 通用DTO：`{resource}.common.dto.ts`，如`product.common.dto.ts`

2. **类/接口命名**：
   - 请求DTO：`{Resource}{Action}RequestDto`，如`ProductCreateRequestDto`
   - 响应DTO：`{Resource}{Action}ResponseDto`，如`ProductDetailResponseDto`
   - 通用DTO：`{Resource}Dto`，如`ProductDto`

3. **字段命名**：
   - 使用驼峰命名法，如`productName`、`createdAt`
   - 字段名应与业务术语保持一致，使用通用语言
   - 避免使用技术术语，如`id`而非`uuid`或`guid`

##### 8.5.5.2 结构设计

1. **分层设计**：
   - **请求DTO**：分为核心请求DTO和扩展请求DTO，核心请求DTO包含必需字段，扩展请求DTO包含可选字段
   - **响应DTO**：分为基础响应DTO和详细响应DTO，基础响应DTO包含核心字段，详细响应DTO包含扩展字段
   - **内部DTO**：用于API层内部数据传输，不对外暴露

2. **字段设计**：
   - 每个字段应有明确的类型定义，避免使用`any`类型
   - 字段应添加适当的注释，说明字段含义和约束
   - 避免深层嵌套结构，建议嵌套深度不超过2层
   - 对于复杂结构，使用组合而非继承

3. **数据类型规范**：
   - 金额字段使用`number`类型，单位为最小货币单位（如分）
   - 日期时间字段使用`string`类型，格式为ISO 8601，如`2023-01-01T12:00:00Z`
   - 布尔字段使用`boolean`类型，避免使用字符串或数字表示布尔值
   - 枚举字段使用字符串类型，避免使用数字枚举

##### 8.5.5.3 验证规则

1. **验证注解**：
   - 使用装饰器进行字段验证，如`@IsNotEmpty()`、`@IsEmail()`、`@Min()`、`@Max()`等
   - 验证规则应与业务规则保持一致
   - 为每个字段添加适当的验证消息，提高错误信息的可读性

2. **验证分组**：
   - 支持按场景分组验证，如创建场景、更新场景、查询场景
   - 使用`@ValidateIf()`注解处理条件验证
   - 使用`@IsOptional()`注解标记可选字段

3. **自定义验证**：
   - 对于复杂的业务验证，实现自定义验证器
   - 自定义验证器应继承自`ValidatorConstraint`接口
   - 自定义验证器应包含清晰的错误消息

##### 8.5.5.4 DTO与领域模型映射

1. **映射原则**：
   - DTO与领域模型应明确分离，避免直接耦合
   - 使用映射器（Mapper）进行DTO与领域模型之间的转换
   - 映射器应包含清晰的映射规则，便于维护和扩展

2. **映射实现**：
   - 实现`toDomain()`方法，将DTO转换为领域模型
   - 实现`fromDomain()`方法，将领域模型转换为DTO
   - 对于复杂映射，考虑使用映射工具如`automapper-ts`

3. **映射规则**：
   - 只映射必要的字段，避免过度映射
   - 对于嵌套结构，使用递归映射
   - 对于集合类型，使用批量映射

##### 8.5.5.5 版本管理

1. **版本策略**：
   - 使用API版本控制，如URL路径版本`/api/v1/catalog/products`
   - 不同版本的API使用不同的DTO定义
   - 版本升级时，保持向后兼容

2. **兼容性处理**：
   - 新增字段：设置默认值，确保旧客户端能正常处理
   - 修改字段：创建新字段，保留旧字段并标记为废弃
   - 删除字段：先标记为废弃，经过足够的过渡期后再删除

3. **废弃字段处理**：
   - 使用`@Deprecated()`注解标记废弃字段
   - 在注释中说明废弃原因和替代方案
   - 在文档中明确废弃字段的生命周期

##### 8.5.5.6 安全设计

1. **数据过滤**：
   - 只返回客户端有权访问的字段
   - 实现字段级权限控制，根据用户角色过滤字段
   - 避免返回敏感信息，如密码、令牌等

2. **敏感信息处理**：
   - 对敏感字段进行脱敏处理，如手机号、身份证号等
   - 实现数据脱敏策略，支持不同场景的脱敏规则
   - 脱敏规则应可配置，便于调整

3. **输入验证**：
   - 对所有输入进行严格验证，防止注入攻击
   - 实现请求大小限制，防止DoS攻击
   - 实现速率限制，防止暴力攻击

##### 8.5.5.7 可维护性设计

1. **复用机制**：
   - 对于通用字段，使用基础DTO进行复用
   - 使用继承或组合实现DTO复用
   - 避免重复定义相同的字段和验证规则

2. **文档生成**：
   - 使用装饰器生成API文档，如`@ApiProperty()`
   - 为每个字段添加清晰的描述，提高文档可读性
   - 自动生成Swagger文档，便于客户端开发者使用

3. **测试支持**：
   - 提供DTO的测试工具类，便于编写单元测试
   - 实现DTO的验证测试，确保验证规则正确
   - 实现DTO的映射测试，确保映射规则正确

##### 8.5.5.8 性能优化

1. **字段精简**：
   - 只包含必要的字段，避免传输不必要的数据
   - 实现字段选择功能，允许客户端指定返回的字段
   - 对于大字段，提供单独的API进行获取

2. **分页设计**：
   - 对于列表查询，实现分页机制
   - 分页DTO包含`page`、`pageSize`、`total`、`totalPages`等字段
   - 提供默认分页参数，避免客户端请求过大

3. **缓存支持**：
   - 实现DTO的缓存机制，避免重复生成相同的DTO
   - 为响应DTO添加缓存控制头，如`Cache-Control`
   - 实现ETag机制，支持条件请求

##### 8.5.5.9 示例

```typescript
// 请求DTO示例
import { IsNotEmpty, IsString, IsNumber, IsOptional, Min, Max } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

@ApiProperty()
export class ProductCreateRequestDto {
  @ApiProperty({ description: '产品名称', example: '高级课程套餐' })
  @IsNotEmpty()
  @IsString()
  productName: string;

  @ApiProperty({ description: '产品代码', example: 'PROD-001' })
  @IsNotEmpty()
  @IsString()
  productCode: string;

  @ApiProperty({ description: '产品价格（分）', example: 99900 })
  @IsNotEmpty()
  @IsNumber()
  @Min(0)
  price: number;

  @ApiProperty({ description: '产品描述', example: '包含10节高级课程' })
  @IsOptional()
  @IsString()
  description?: string;

  @ApiProperty({ description: '产品分类', example: 'course' })
  @IsOptional()
  @IsString()
  category?: string;
}

// 响应DTO示例
import { ApiProperty } from '@nestjs/swagger';

export class ProductDetailResponseDto {
  @ApiProperty({ description: '产品ID', example: '123e4567-e89b-12d3-a456-426614174000' })
  id: string;

  @ApiProperty({ description: '产品名称', example: '高级课程套餐' })
  productName: string;

  @ApiProperty({ description: '产品代码', example: 'PROD-001' })
  productCode: string;

  @ApiProperty({ description: '产品价格（分）', example: 99900 })
  price: number;

  @ApiProperty({ description: '产品描述', example: '包含10节高级课程' })
  description?: string;

  @ApiProperty({ description: '产品分类', example: 'course' })
  category?: string;

  @ApiProperty({ description: '产品状态', example: 'active' })
  status: string;

  @ApiProperty({ description: '创建时间', example: '2023-01-01T12:00:00Z' })
  createdAt: string;

  @ApiProperty({ description: '更新时间', example: '2023-01-01T12:00:00Z' })
  updatedAt: string;
}
```

## 9. 业务域重构方案详细设计

### 9.1 重构优先级与资源需求

| 业务域 | 优先级 | 估算工作量（人天） | 核心资源需求 | 依赖关系 |
|---------|---------|-------------------|-------------|---------|
| **Catalog** | 1 | 15 | 后端开发×1, DBA×0.5 | 无 |
| **Contract** | 2 | 20 | 后端开发×1, 测试×0.5 | Catalog |
| **Financial** | 3 | 25 | 后端开发×1, 测试×0.5 | Contract |
| **Services** | 4 | 30 | 后端开发×2, 测试×1 | Contract |
| **Identity** | 5 | 15 | 后端开发×1 | 无 |
| **Placement** | 6 | 20 | 后端开发×1 | Services |
| **Query** | 7 | 10 | 后端开发×1 | 所有业务域 |

### 9.2 各业务域重构方案

#### 9.2.1 Catalog域重构方案

**核心问题**：
- 依赖方向问题：Domain层直接依赖Infrastructure层
- CQRS实现不清晰：命令和查询混合在同一服务中
- 事件驱动架构不完善：缺乏专门的事件处理器

**重构目标**：
- 实现清晰的CQRS模式，分离命令和查询
- 建立正确的依赖方向：Domain层不依赖Infrastructure层
- 实现完整的事件驱动架构
- 封装领域规则到领域对象中

**实施步骤**：
1. 提取领域实体、值对象和聚合根
2. 抽象仓储接口，分离数据访问逻辑
3. 实现命令处理器，封装业务规则
4. 实现查询处理器，优化查询性能
5. 实现事件总线和事件处理器
6. 更新模块依赖关系，修复依赖倒置问题
7. 编写单元测试和集成测试

**验收标准**：
- 所有现有功能正常工作
- 领域层不直接依赖基础设施层
- CQRS模式清晰实现
- 事件驱动架构完整实现
- 代码覆盖率达到80%以上

#### 9.2.2 Contract域重构方案

**核心问题**：
- 事务管理不统一：部分操作缺乏事务保障
- 领域模型偏贫血：业务规则分散在服务中
- 事件处理机制不完善：缺乏专门的事件处理器

**重构目标**：
- 统一事务管理，明确事务边界
- 实现充血模型，封装业务规则到领域对象中
- 完善事件驱动架构
- 建立清晰的领域边界

**实施步骤**：
1. 提取领域实体、值对象和聚合根
2. 实现事务管理，明确事务边界
3. 重构领域服务，封装业务规则到领域对象中
4. 实现事件处理器，处理跨域事件
5. 更新模块依赖关系
6. 编写单元测试和集成测试

**验收标准**：
- 所有现有功能正常工作
- 事务管理统一，边界清晰
- 领域模型为充血模型
- 事件驱动架构完整实现
- 代码覆盖率达到80%以上

#### 9.2.3 Financial域重构方案

**核心问题**：
- 领域规则封装不充分：业务规则分散在服务中
- 事务管理不完善：部分操作缺乏事务保障
- 事件驱动架构实现不完整

**重构目标**：
- 封装领域规则到领域对象中
- 统一事务管理，明确事务边界
- 完善事件驱动架构
- 建立清晰的领域边界

**实施步骤**：
1. 提取领域实体、值对象和聚合根
2. 实现事务管理，明确事务边界
3. 重构领域服务，封装业务规则到领域对象中
4. 实现事件处理器，处理跨域事件
5. 更新模块依赖关系
6. 编写单元测试和集成测试

**验收标准**：
- 所有现有功能正常工作
- 领域规则充分封装到领域对象中
- 事务管理统一，边界清晰
- 事件驱动架构完整实现
- 代码覆盖率达到80%以上

#### 9.2.4 Services域重构方案

**核心问题**：
- 异步处理机制不完善：部分操作缺乏异步支持
- Outbox模式未实现：事件可靠投递机制缺失
- 事件驱动架构实现不完整

**重构目标**：
- 完善异步处理机制
- 实现Outbox模式，确保事件可靠投递
- 完善事件驱动架构
- 建立清晰的领域边界

**实施步骤**：
1. 提取领域实体、值对象和聚合根
2. 实现异步处理机制
3. 实现Outbox模式，确保事件可靠投递
4. 实现事件处理器，处理跨域事件
5. 更新模块依赖关系
6. 编写单元测试和集成测试

**验收标准**：
- 所有现有功能正常工作
- 异步处理机制完善
- Outbox模式完整实现
- 事件驱动架构完整实现
- 代码覆盖率达到80%以上

#### 9.2.5 Identity域重构方案

**核心问题**：
- 领域模型偏贫血：业务规则分散在服务中
- 依赖方向问题：Domain层直接依赖Infrastructure层

**重构目标**：
- 实现充血模型，封装业务规则到领域对象中
- 建立正确的依赖方向：Domain层不依赖Infrastructure层
- 建立清晰的领域边界

**实施步骤**：
1. 提取领域实体、值对象和聚合根
2. 抽象仓储接口，分离数据访问逻辑
3. 重构领域服务，封装业务规则到领域对象中
4. 更新模块依赖关系，修复依赖倒置问题
5. 编写单元测试和集成测试

**验收标准**：
- 所有现有功能正常工作
- 领域层不直接依赖基础设施层
- 领域模型为充血模型
- 代码覆盖率达到80%以上

#### 9.2.6 Placement域重构方案

**核心问题**：
- 事件驱动架构实现不完整：缺乏专门的事件处理器
- 领域模型偏贫血：业务规则分散在服务中

**重构目标**：
- 完善事件驱动架构
- 实现充血模型，封装业务规则到领域对象中
- 建立清晰的领域边界

**实施步骤**：
1. 提取领域实体、值对象和聚合根
2. 实现事件处理器，处理跨域事件
3. 重构领域服务，封装业务规则到领域对象中
4. 更新模块依赖关系
5. 编写单元测试和集成测试

**验收标准**：
- 所有现有功能正常工作
- 事件驱动架构完整实现
- 领域模型为充血模型
- 代码覆盖率达到80%以上

#### 9.2.7 Query域重构方案

**核心问题**：
- CQRS实现不清晰：与其他业务域耦合严重
- Read Model优化不足：查询性能有待提升

**重构目标**：
- 实现清晰的CQRS模式，分离Read Model
- 优化Read Model，提升查询性能
- 建立清晰的领域边界
- 支持独立部署和扩展

**实施步骤**：
1. 设计和实现专用的Read Model
2. 实现查询处理器，优化查询性能
3. 建立Read Model更新机制
4. 分离Query域与其他业务域的依赖关系
5. 编写单元测试和集成测试

**验收标准**：
- 所有现有查询功能正常工作
- 查询性能提升50%以上
- Read Model与Write Model保持数据一致性
- 代码覆盖率达到80%以上

### 9.3 模块化边界划分

| 模块名称 | 边界定义 | 依赖关系 | 接口规范 |
|---------|---------|---------|---------|
| **Catalog** | 产品/服务类型管理 | 依赖Shared Kernel | RESTful API + 事件驱动 |
| **Contract** | 合同/权益/台账/预占 | 依赖Catalog + Shared Kernel | RESTful API + 事件驱动 |
| **Financial** | 导师结算/申诉/支付参数 | 依赖Contract + Services + Shared Kernel | RESTful API + 事件驱动 |
| **Services** | 各种session/service registry | 依赖Contract + Shared Kernel | RESTful API + 事件驱动 |
| **Identity** | 用户/角色/档案 | 依赖Shared Kernel | RESTful API |
| **Placement** | 职位申请/推荐 | 依赖Services + Shared Kernel | RESTful API + 事件驱动 |
| **Query** | 读模型/报表 | 依赖所有业务域的事件 | RESTful API |

### 9.4 接口定义规范

1. **领域接口规范**：
   - 仓储接口：定义在domain层，实现在infrastructure层
   - 领域服务：纯业务逻辑，不依赖技术细节
   - 实体/值对象：封装业务规则和不变量

2. **应用接口规范**：
   - 命令接口：输入DTO，返回操作结果
   - 查询接口：输入查询条件，返回Read Model
   - 事件接口：定义事件结构和处理器接口

3. **API接口规范**：
   - RESTful API设计
   - 统一的错误响应格式
   - 版本控制
   - 输入验证

4. **事件接口规范**：
   - 事件命名：领域名.事件名.版本号
   - 事件结构：id、type、payload、timestamp、metadata
   - 事件版本管理：语义化版本号

### 9.5 依赖管理措施

1. **依赖方向控制**：
   - 严格控制依赖方向，确保内层模块不依赖外层模块
   - 使用依赖倒置原则，通过接口抽象依赖关系
   - 建立依赖检查机制，定期检查依赖关系

2. **共享代码管理**：
   - 严格控制Shared Kernel的内容，只包含领域契约
   - 建立共享代码审查机制，避免Shared Kernel膨胀
   - 定期清理Shared Kernel中的无效代码

3. **模块间通信**：
   - 优先使用事件驱动方式进行模块间通信
   - 对于同步通信，使用接口抽象，避免直接依赖
   - 建立模块间通信监控机制，确保通信可靠

## 10. 质量保障措施与验收标准

### 10.1 质量保障措施

1. **代码审查**：
   - 建立代码审查流程
   - 定义代码审查标准
   - 使用自动化代码审查工具

2. **测试策略**：
   - 单元测试：覆盖领域模型、命令/查询处理器、事件处理器
   - 集成测试：验证各层交互
   - 端到端测试：验证完整业务流程
   - 性能测试：验证系统性能
   - 回归测试：确保重构不引入新问题

3. **持续集成/持续部署**：
   - 自动化构建
   - 自动化测试
   - 自动化部署
   - 监控和告警

4. **文档管理**：
   - 领域模型文档
   - 架构设计文档
   - API文档
   - 重构总结报告

### 10.2 验收标准

1. **功能验收**：
   - 所有现有功能正常工作
   - 新功能符合需求
   - 系统性能达到预期指标

2. **架构验收**：
   - 依赖方向正确
   - 分层架构实现
   - CQRS模式实现
   - 事件驱动架构实现
   - 统一事务管理

3. **代码质量验收**：
   - 代码覆盖率达到80%以上
   - 代码复杂度符合要求
   - 没有重复代码
   - 代码可读性好

4. **文档验收**：
   - 领域模型文档完整
   - 架构设计文档完整
   - API文档完整
   - 重构总结报告完整

## 11. 结论

本重构方案基于DDD理论框架，针对当前项目存在的依赖方向问题、领域模型偏贫血、事务管理不统一、CQRS实现不清晰、事件驱动架构不完善等问题，提出了系统性的解决方案。通过建立清晰的领域边界、实现充血模型、统一事务管理、明确实现CQRS模式和事件驱动架构，将显著提升代码的可维护性、可扩展性与可测试性。

重构方案采用分阶段实施策略，从核心业务域开始，逐步推广到其他域，确保重构过程的可控性和安全性。每个业务域都有详细的重构方案、实施步骤、资源需求、潜在风险及应对策略，便于跟踪进度和评估效果。同时，针对可能出现的风险，制定了相应的应对措施，确保重构工作的顺利进行。

通过本重构方案的实施，项目将能够更好地应对业务增长和变化，支持快速迭代和扩展，为长期的业务发展提供坚实的技术支持。